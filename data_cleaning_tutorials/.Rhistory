typeof(wrk_data$collection_date)
wrk_data$collection_date[1]
# Let's just type out the dates and try to subtract them.... ERROR
# "2011-03-25" - "2001-03-25"
# Now let's try a computation of two datetime objects.
as.Date("2018-05-19") - wrk_data$collection_date[1]
head(in_data$age, n = 10)
head(wrk_data$age)
# If we run grep along the column, it returns the row number of the matching columns
grep('^(\\d{4})-(\\d{2})-(\\d{2})', wrk_data$age, perl = TRUE)[1:10]
# Let's make a vector of these
birthdate_rows = grep(
'^(\\d{4})-(\\d{2})-(\\d{2})',
in_data$age,
perl = TRUE)
# Let's look at the values
in_data[birthdate_rows, "age"][1:10]
months_between <- function(end_date, start_date) {
end_dt <- as.POSIXlt(end_date)
start_dt <- as.POSIXlt(start_date)
# 12 times the elapsed years + the elapsed months intrayear
return(12 * (end_dt$year - start_dt$year) + (end_dt$mon - start_dt$mon))
}
# Test it
months_between("2016-02-23", "2015-01-28")
head(wrk_data$age)
wrk_data$age = in_data$age
# Compute months_between, convert to strings, update the dataframe
wrk_data[birthdate_rows, "age"] =
as.character(
months_between(
in_data[birthdate_rows, "collection_date"],
in_data[birthdate_rows, "age"]
)
)
# Convert the now-uniform column to numeric values
wrk_data[, 'age'] = as.integer(wrk_data$age)
# Convert months to decimal years
wrk_data[, 'age'] = wrk_data[, 'age']/12
head(wrk_data[, 'age'])
head(wrk_data)
# Box and Whisker plot of volume_consumed by unit type
plot(as.factor(wrk_data$units), in_data[, "volume_consumed"])
# Let's aggregate the volume and weight numbers by their respective units and take the mean
volume_means = aggregate(
wrk_data[, c("volume_consumed", "weight")],
list(units = wrk_data$units),
mean)
volume_means
# Ratio of the metric volume mean to the imperial volume mean
volume_means[which(volume_means$units == "metric"),  "volume_consumed"] /
volume_means[volume_means$units == "imperial",  "volume_consumed"]
# Ratio of the metric weight mean to the imperial weight mean
volume_means[which(volume_means$units == "metric"),  "weight"] /
volume_means[volume_means$units == "imperial",  "weight"]
# Convert volume - ml to oz
wrk_data[which(wrk_data$units == 'metric'), "volume_consumed"] =
wrk_data[which(wrk_data$units == 'metric'), "volume_consumed"]/29.6
head(wrk_data[which(wrk_data$units == 'metric'), "volume_consumed"])
# Convert weight - kg to lbs
wrk_data[which(wrk_data$units == 'metric'), "weight"] =
wrk_data[which(wrk_data$units == 'metric'), "weight"]/1.453592
head(wrk_data[which(wrk_data$units == 'metric'), "weight"])
plot(as.factor(wrk_data$drink_type), wrk_data$volume_consumed)
# Make a copy to use in the appendix
impute_data = wrk_data
# Remove all rows where sex is blank
wrk_data = wrk_data[!(wrk_data$sex == ""),]
head(wrk_data)
model_data = wrk_data
model_data = model_data[, !(names(model_data) %in% c("collection_date", "units", "volume_consumed", "X", "drink_type"))]
library(ggpubr)
# Box plot of sex and weight
p1 = qplot(sex, weight, color = sex, data = model_data, geom = "boxplot")
# Box plot of sex and BAC
p2 = qplot(sex, BAC, color = sex, data = model_data, geom = "boxplot")
# Scatter plot of num_drinks and BAC
p3 = qplot(num_drinks, BAC, colour = sex,
data = model_data)
# Scatter plot of weight and BAC
p4 = qplot(weight, BAC, color=sex, data = model_data)
ggarrange(p1, p2, p3, p4)
model_data$sex = ifelse(model_data$sex == "Male", 1, 0)
lm1 = lm(BAC ~ ., data = model_data)
summary(lm1)
# Set sex as a binary variable
impute_data[which(impute_data$sex == "Male"), 'sex'] = 1
impute_data[which(impute_data$sex == "Female"), 'sex'] = 0
# Set the data type to numeric
impute_data$sex = as.numeric(impute_data$sex)
# Use all rows where `sex` is available as the training data.
# We will predict all of the missing observations
train = impute_data[which(impute_data$sex != ""),]
missing = impute_data[which(is.na(impute_data$sex)),]
missing = missing[, (names(missing) %in% c('num_drinks', 'BAC'))]
# Fit
model <- glm (sex ~ num_drinks + BAC, data = train, family = binomial)
summary(model)
# Make the prediction
prediction = predict(model, missing, type = 'response')
range(prediction)
prediction = ifelse(prediction >= .5, "Male", "Female")
impute_data[names(prediction), 'sex'] = prediction
# Good! Now we only have two categories, "Male", and "Female"
unique(wrk_data$sex)
qplot(num_drinks, BAC, colour = sex,
data = wrk_data)
knitr::opts_chunk$set(echo = TRUE)
version
library(ggplot2)
# Loading the CSV
# Py/Pandas: pd.read_csv('./horrible_data.csv', index=0)
in_data = read.csv('./horrible_data.csv', stringsAsFactors=FALSE)
# Let's duplicate the data so we can keep a copy of the original.
# When we update data we will update wrk_data not in_data
wrk_data = cbind(in_data)
# Setting the row names to the `ix` column
row.names(in_data) = in_data$ix
# Py/Pandas: df.head()
head(in_data)
# Let's use the super handy built-in to generate a histogram
hist(in_data$BAC)
# Let's also look at the overall shape of the dataset.
nrow(in_data)
ncol(in_data)
sex_vals = unique(in_data$sex)
sex_vals
# Selecting rows where
head(in_data[which(in_data$sex == "Male"), ])
head(which(in_data$sex == "Male"))
# A vector of all the values that should be classified as "Male"
male_values = c("Male", "meal", "male", "M")
# Now we will use the `%in%` operator to select all rows where the `sex` column value is
# in the set of possible values.
head(in_data[which(in_data$sex %in% male_values), c("BAC", "sex")], n = 10)
wrk_data[which(wrk_data$sex %in% male_values), "sex"] = "Male"
# Let's do the same thing for "Female"
female_values = c("F", "female", "Female", "femeal")
wrk_data[which(wrk_data$sex %in% female_values), "sex"] = "Female"
# SUCCESS! If we examine the unique set of values for `sex` in wrk_data
# we see that Male and Female are now standardized.
unique(wrk_data$sex)
qplot(num_drinks, BAC, colour = sex,
data = wrk_data)
# Let's print out the list of unique items in the units column
unique(in_data$units)
metric_values = c("metric", "SI")
wrk_data[which(wrk_data$units %in% metric_values), "units"] = "metric"
# It's bad practice to have the absense of information imply a definitive value.
# I know (because I made the dataset) that all values that are not marked as metric
# use the America/imperial units.
wrk_data[which(!(wrk_data$units %in% metric_values)), "units"] = "imperial"
# Let's check our work.
unique(wrk_data$units)
unique(wrk_data$drink_type)
# Vectors for each type of alcoholic beverage.
wine_options = c("Merlot", "Vino", "Vin", "Cab")
beer_options = c("Bud Light", "IPA", "Beer", "Franziskaner Weissbier", "Warsteiner")
hard_liquor_options = c("shots", "Scotch", "whiskey", "vidka")
wrk_data[which(wrk_data$drink_type %in% wine_options), "drink_type"] =
"Wine"
wrk_data[which(wrk_data$drink_type %in% beer_options), "drink_type"] =
"Beer"
wrk_data[which(wrk_data$drink_type %in% hard_liquor_options), "drink_type"] =
"Hard Liquor"
unique(wrk_data$drink_type)
# Load the datetime utilities libraries
library(lubridate)
library(anytime)
# Examine the type of the collection_date column. Note that R currently classifies
# it as "character"
typeof(in_data$collection_date)
# Use anytime to convert the column to POSIXct times.
wrk_data[,'collection_date'] = anydate(wrk_data$collection_date)
# Note that the type has changed to "double", don't worry, this is really a datetime.
typeof(wrk_data$collection_date)
wrk_data$collection_date[1]
# Let's just type out the dates and try to subtract them.... ERROR
# "2011-03-25" - "2001-03-25"
# Now let's try a computation of two datetime objects.
as.Date("2018-05-19") - wrk_data$collection_date[1]
head(in_data$age, n = 10)
head(wrk_data$age)
# If we run grep along the column, it returns the row number of the matching columns
grep('^(\\d{4})-(\\d{2})-(\\d{2})', wrk_data$age, perl = TRUE)[1:10]
# Let's make a vector of these
birthdate_rows = grep(
'^(\\d{4})-(\\d{2})-(\\d{2})',
in_data$age,
perl = TRUE)
# Let's look at the values
in_data[birthdate_rows, "age"][1:10]
months_between <- function(end_date, start_date) {
end_dt <- as.POSIXlt(end_date)
start_dt <- as.POSIXlt(start_date)
# 12 times the elapsed years + the elapsed months intrayear
return(12 * (end_dt$year - start_dt$year) + (end_dt$mon - start_dt$mon))
}
# Test it
months_between("2016-02-23", "2015-01-28")
head(wrk_data$age)
wrk_data$age = in_data$age
# Compute months_between, convert to strings, update the dataframe
wrk_data[birthdate_rows, "age"] =
as.character(
months_between(
in_data[birthdate_rows, "collection_date"],
in_data[birthdate_rows, "age"]
)
)
# Convert the now-uniform column to numeric values
wrk_data[, 'age'] = as.integer(wrk_data$age)
# Convert months to decimal years
wrk_data[, 'age'] = wrk_data[, 'age']/12
head(wrk_data[, 'age'])
head(wrk_data)
# Box and Whisker plot of volume_consumed by unit type
plot(as.factor(wrk_data$units), in_data[, "volume_consumed"])
# Let's aggregate the volume and weight numbers by their respective units
# and take the mean
volume_means = aggregate(
wrk_data[, c("volume_consumed", "weight")],
list(units = wrk_data$units),
mean)
volume_means
# Ratio of the metric volume mean to the imperial volume mean
volume_means[which(volume_means$units == "metric"),  "volume_consumed"] /
volume_means[volume_means$units == "imperial",  "volume_consumed"]
# Ratio of the metric weight mean to the imperial weight mean
volume_means[which(volume_means$units == "metric"),  "weight"] /
volume_means[volume_means$units == "imperial",  "weight"]
# Convert volume - ml to oz
wrk_data[which(wrk_data$units == 'metric'), "volume_consumed"] =
wrk_data[which(wrk_data$units == 'metric'), "volume_consumed"]/29.6
head(wrk_data[which(wrk_data$units == 'metric'), "volume_consumed"])
# Convert weight - kg to lbs
wrk_data[which(wrk_data$units == 'metric'), "weight"] =
wrk_data[which(wrk_data$units == 'metric'), "weight"]/1.453592
head(wrk_data[which(wrk_data$units == 'metric'), "weight"])
plot(as.factor(wrk_data$drink_type), wrk_data$volume_consumed)
# Make a copy to use in the appendix
impute_data = wrk_data
# Remove all rows where sex is blank
wrk_data = wrk_data[!(wrk_data$sex == ""),]
head(wrk_data)
model_data = wrk_data
model_data = model_data[, !(names(model_data) %in% c(
"collection_date",
"units",
"volume_consumed",
"X",
"drink_type"
)
)
]
library(ggpubr)
# Box plot of sex and weight
p1 = qplot(sex, weight, color = sex, data = model_data, geom = "boxplot")
# Box plot of sex and BAC
p2 = qplot(sex, BAC, color = sex, data = model_data, geom = "boxplot")
# Scatter plot of num_drinks and BAC
p3 = qplot(num_drinks, BAC, colour = sex,
data = model_data)
# Scatter plot of weight and BAC
p4 = qplot(weight, BAC, color=sex, data = model_data)
ggarrange(p1, p2, p3, p4)
model_data$sex = ifelse(model_data$sex == "Male", 1, 0)
lm1 = lm(BAC ~ ., data = model_data)
summary(lm1)
# Set sex as a binary variable
impute_data[which(impute_data$sex == "Male"), 'sex'] = 1
impute_data[which(impute_data$sex == "Female"), 'sex'] = 0
# Set the data type to numeric
impute_data$sex = as.numeric(impute_data$sex)
# Use all rows where `sex` is available as the training data.
# We will predict all of the missing observations
train = impute_data[which(impute_data$sex != ""),]
missing = impute_data[which(is.na(impute_data$sex)),]
missing = missing[, (names(missing) %in% c('num_drinks', 'BAC'))]
# Fit
model <- glm (sex ~ num_drinks + BAC, data = train, family = binomial)
summary(model)
# Make the prediction
prediction = predict(model, missing, type = 'response')
range(prediction)
prediction = ifelse(prediction >= .5, "Male", "Female")
impute_data[names(prediction), 'sex'] = prediction
# Good! Now we only have two categories, "Male", and "Female"
unique(wrk_data$sex)
qplot(num_drinks, BAC, colour = sex,
data = wrk_data)
ggarrange(p1, p2, p3, p4)
volume_means = aggregate(
wrk_data[, c("volume_consumed", "weight")],
list(units = wrk_data$units),
mean)
volume_means
volume_means[which(volume_means$units == "metric"),  "volume_consumed"] /
volume_means[volume_means$units == "imperial",  "volume_consumed"]
volume_means[which(volume_means$units == "metric"),  "weight"] /
volume_means[volume_means$units == "imperial",  "weight"]
wrk_data[which(wrk_data$units == 'metric'), "volume_consumed"] =
wrk_data[which(wrk_data$units == 'metric'), "volume_consumed"]/29.6
head(wrk_data[which(wrk_data$units == 'metric'), "volume_consumed"])
wrk_data[which(wrk_data$units == 'metric'), "weight"] =
wrk_data[which(wrk_data$units == 'metric'), "weight"]/.453592
head(wrk_data[which(wrk_data$units == 'metric'), "weight"])
plot(as.factor(wrk_data$drink_type), wrk_data$volume_consumed)
impute_data = wrk_data
wrk_data = wrk_data[!(wrk_data$sex == ""),]
head(wrk_data)
model_data = wrk_data
model_data = model_data[, !(names(model_data) %in% c(
"collection_date",
"units",
"volume_consumed",
"X",
"drink_type"
)
)
]
library(ggpubr)
p1 = qplot(sex, weight, color = sex, data = model_data, geom = "boxplot")
p2 = qplot(sex, BAC, color = sex, data = model_data, geom = "boxplot")
p3 = qplot(num_drinks, BAC, colour = sex,
data = model_data)
p4 = qplot(weight, BAC, color=sex, data = model_data)
ggarrange(p1, p2, p3, p4)
knitr::opts_chunk$set(echo = TRUE)
version
library(ggplot2)
# Loading the CSV
# Py/Pandas: pd.read_csv('./horrible_data.csv', index=0)
in_data = read.csv('./horrible_data.csv', stringsAsFactors=FALSE)
# Let's duplicate the data so we can keep a copy of the original.
# When we update data we will update wrk_data not in_data
wrk_data = cbind(in_data)
# Setting the row names to the `ix` column
row.names(in_data) = in_data$ix
# Py/Pandas: df.head()
head(in_data)
# Let's use the super handy built-in to generate a histogram
hist(in_data$BAC)
# Let's also look at the overall shape of the dataset.
nrow(in_data)
ncol(in_data)
sex_vals = unique(in_data$sex)
sex_vals
# Selecting rows where
head(in_data[which(in_data$sex == "Male"), ])
head(which(in_data$sex == "Male"))
# A vector of all the values that should be classified as "Male"
male_values = c("Male", "meal", "male", "M")
# Now we will use the `%in%` operator to select all rows where the `sex` column value is
# in the set of possible values.
head(in_data[which(in_data$sex %in% male_values), c("BAC", "sex")], n = 10)
wrk_data[which(wrk_data$sex %in% male_values), "sex"] = "Male"
# Let's do the same thing for "Female"
female_values = c("F", "female", "Female", "femeal")
wrk_data[which(wrk_data$sex %in% female_values), "sex"] = "Female"
# SUCCESS! If we examine the unique set of values for `sex` in wrk_data
# we see that Male and Female are now standardized.
unique(wrk_data$sex)
qplot(num_drinks, BAC, colour = sex,
data = wrk_data)
# Let's print out the list of unique items in the units column
unique(in_data$units)
metric_values = c("metric", "SI")
wrk_data[which(wrk_data$units %in% metric_values), "units"] = "metric"
# It's bad practice to have the absense of information imply a definitive value.
# I know (because I made the dataset) that all values that are not marked as metric
# use the America/imperial units.
wrk_data[which(!(wrk_data$units %in% metric_values)), "units"] = "imperial"
# Let's check our work.
unique(wrk_data$units)
unique(wrk_data$drink_type)
# Vectors for each type of alcoholic beverage.
wine_options = c("Merlot", "Vino", "Vin", "Cab")
beer_options = c("Bud Light", "IPA", "Beer", "Franziskaner Weissbier", "Warsteiner")
hard_liquor_options = c("shots", "Scotch", "whiskey", "vidka")
wrk_data[which(wrk_data$drink_type %in% wine_options), "drink_type"] =
"Wine"
wrk_data[which(wrk_data$drink_type %in% beer_options), "drink_type"] =
"Beer"
wrk_data[which(wrk_data$drink_type %in% hard_liquor_options), "drink_type"] =
"Hard Liquor"
unique(wrk_data$drink_type)
# Load the datetime utilities libraries
library(lubridate)
library(anytime)
# Examine the type of the collection_date column. Note that R currently classifies
# it as "character"
typeof(in_data$collection_date)
# Use anytime to convert the column to POSIXct times.
wrk_data[,'collection_date'] = anydate(wrk_data$collection_date)
# Note that the type has changed to "double", don't worry, this is really a datetime.
typeof(wrk_data$collection_date)
wrk_data$collection_date[1]
# Let's just type out the dates and try to subtract them.... ERROR
# "2011-03-25" - "2001-03-25"
# Now let's try a computation of two datetime objects.
as.Date("2018-05-19") - wrk_data$collection_date[1]
head(in_data$age, n = 10)
head(wrk_data$age)
# If we run grep along the column, it returns the row number of the matching columns
grep('^(\\d{4})-(\\d{2})-(\\d{2})', wrk_data$age, perl = TRUE)[1:10]
# Let's make a vector of these
birthdate_rows = grep(
'^(\\d{4})-(\\d{2})-(\\d{2})',
in_data$age,
perl = TRUE)
# Let's look at the values
in_data[birthdate_rows, "age"][1:10]
months_between <- function(end_date, start_date) {
end_dt <- as.POSIXlt(end_date)
start_dt <- as.POSIXlt(start_date)
# 12 times the elapsed years + the elapsed months intrayear
return(12 * (end_dt$year - start_dt$year) + (end_dt$mon - start_dt$mon))
}
# Test it
months_between("2016-02-23", "2015-01-28")
head(wrk_data$age)
wrk_data$age = in_data$age
# Compute months_between, convert to strings, update the dataframe
wrk_data[birthdate_rows, "age"] =
as.character(
months_between(
in_data[birthdate_rows, "collection_date"],
in_data[birthdate_rows, "age"]
)
)
# Convert the now-uniform column to numeric values
wrk_data[, 'age'] = as.integer(wrk_data$age)
# Convert months to decimal years
wrk_data[, 'age'] = wrk_data[, 'age']/12
head(wrk_data[, 'age'])
head(wrk_data)
# Box and Whisker plot of volume_consumed by unit type
plot(as.factor(wrk_data$units), in_data[, "volume_consumed"])
# Let's aggregate the volume and weight numbers by their respective units
# and take the mean
volume_means = aggregate(
wrk_data[, c("volume_consumed", "weight")],
list(units = wrk_data$units),
mean)
volume_means
# Ratio of the metric volume mean to the imperial volume mean
volume_means[which(volume_means$units == "metric"),  "volume_consumed"] /
volume_means[volume_means$units == "imperial",  "volume_consumed"]
# Ratio of the metric weight mean to the imperial weight mean
volume_means[which(volume_means$units == "metric"),  "weight"] /
volume_means[volume_means$units == "imperial",  "weight"]
# Convert volume - ml to oz
wrk_data[which(wrk_data$units == 'metric'), "volume_consumed"] =
wrk_data[which(wrk_data$units == 'metric'), "volume_consumed"]/29.6
head(wrk_data[which(wrk_data$units == 'metric'), "volume_consumed"])
# Convert weight - kg to lbs
wrk_data[which(wrk_data$units == 'metric'), "weight"] =
wrk_data[which(wrk_data$units == 'metric'), "weight"]/.453592
head(wrk_data[which(wrk_data$units == 'metric'), "weight"])
plot(as.factor(wrk_data$drink_type), wrk_data$volume_consumed)
# Make a copy to use in the appendix
impute_data = wrk_data
# Remove all rows where sex is blank
wrk_data = wrk_data[!(wrk_data$sex == ""),]
head(wrk_data)
model_data = wrk_data
model_data = model_data[, !(names(model_data) %in% c(
"collection_date",
"units",
"volume_consumed",
"X",
"drink_type"
)
)
]
library(ggpubr)
# Box plot of sex and weight
p1 = qplot(sex, weight, color = sex, data = model_data, geom = "boxplot")
# Box plot of sex and BAC
p2 = qplot(sex, BAC, color = sex, data = model_data, geom = "boxplot")
# Scatter plot of num_drinks and BAC
p3 = qplot(num_drinks, BAC, colour = sex,
data = model_data)
# Scatter plot of weight and BAC
p4 = qplot(weight, BAC, color=sex, data = model_data)
ggarrange(p1, p2, p3, p4)
model_data$sex = ifelse(model_data$sex == "Male", 1, 0)
lm1 = lm(BAC ~ ., data = model_data)
summary(lm1)
# Set sex as a binary variable
impute_data[which(impute_data$sex == "Male"), 'sex'] = 1
impute_data[which(impute_data$sex == "Female"), 'sex'] = 0
# Set the data type to numeric
impute_data$sex = as.numeric(impute_data$sex)
# Use all rows where `sex` is available as the training data.
# We will predict all of the missing observations
train = impute_data[which(impute_data$sex != ""),]
missing = impute_data[which(is.na(impute_data$sex)),]
missing = missing[, (names(missing) %in% c('num_drinks', 'BAC'))]
# Fit
model <- glm (sex ~ num_drinks + BAC, data = train, family = binomial)
summary(model)
# Make the prediction
prediction = predict(model, missing, type = 'response')
range(prediction)
prediction = ifelse(prediction >= .5, "Male", "Female")
impute_data[names(prediction), 'sex'] = prediction
# Good! Now we only have two categories, "Male", and "Female"
unique(wrk_data$sex)
qplot(num_drinks, BAC, colour = sex,
data = wrk_data)
